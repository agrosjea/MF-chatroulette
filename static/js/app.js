// Generated by CoffeeScript 1.6.3
var MainCtrl, app;

app = angular.module('app', []);

app.config([
  '$sceProvider', function($sceProvider) {
    return $sceProvider.enabled(false);
  }
]);

app.factory('settings', function() {
  return {
    sockUrl: document.querySelector('link[rel=sockUrl]').getAttribute('href'),
    gumConf: {
      audio: true,
      video: {
        mandatory: {
          minWidth: 640,
          maxWidth: 640,
          minHeight: 480,
          maxHeight: 480
        }
      }
    },
    peerConf: {
      iceServers: [createIceServer('stun:stun.l.google.com:19302'), createIceServer('stun:stunserver.org'), createIceServer('stun:stun01.sipphone.com'), createIceServer('stun:stun.ekiga.net'), createIceServer('stun:stun.fwdnet.net'), createIceServer('turn:wlsvps1.mooo.com:3478', 'uchicago', 'roulette')]
    }
  };
});

app.factory('moment', function() {
  return moment;
});

app.factory('sockjs', function($rootScope) {
  var sockjs;
  sockjs = {};
  sockjs.newSocket = function(url) {
    var socket;
    socket = new SockJS(url);
    socket.onopen = function() {
      return $rootScope.$apply(function() {
        return $rootScope.$broadcast('sockjs:open');
      });
    };
    socket.onmessage = function(e) {
      return $rootScope.$apply(function() {
        return $rootScope.$broadcast('sockjs:message', e.data);
      });
    };
    socket.onerror = function(e) {
      return $rootScope.$apply(function() {
        return $rootScope.$broadcast('sockjs:error', e.data);
      });
    };
    socket.onclose = function() {
      return $rootScope.$apply(function() {
        return $rootScope.$broadcast('sockjs:close');
      });
    };
    sockjs.socket = socket;
    return sockjs.sendJSON = function(data) {
      return socket.send(JSON.stringify(data));
    };
  };
  $rootScope.$on('sockjs:message', function(e, data) {
    data = JSON.parse(data);
    if (data.type != null) {
      return $rootScope.$broadcast("sockjs:" + data.type, data);
    }
  });
  return sockjs;
});

app.directive('scrollBottom', function($timeout) {
  return function(scope, element, attrs) {
    return scope.$watch('messages.length', function() {
      return $timeout(function() {
        return element.animate({
          scrollTop: element.prop("scrollHeight")
        }, 'fast');
      }, 10);
    });
  };
});

MainCtrl = function($rootScope, $scope, $timeout, settings, moment, sockjs) {
  var dtNow;
  if (!getUserMedia) {
    $scope.noWebRTC = true;
    return;
  }
  dtNow = function() {
    return "[" + (moment().format('MM/DD/YYYY hh:mm:ss A')) + "]";
  };
  $scope.supported = true;
  $scope.connected = false;
  $scope.waiting = true;
  $scope.localVerified = false;
  $scope.remoteVerified = false;
  $scope.messages = [];
  return getUserMedia({
    audio: true,
    video: true
  }, function(stream) {
    var conn;
    attachMediaStream($('#local-video')[0], stream);
    $scope.toggleLocalStream = function(type) {
      var t, tracks, _i, _len, _results;
      tracks = null;
      if (type === 'audio') {
        tracks = stream.getAudioTracks();
      } else {
        tracks = stream.getVideoTracks();
      }
      _results = [];
      for (_i = 0, _len = tracks.length; _i < _len; _i++) {
        t = tracks[_i];
        _results.push(t.enabled = !t.enabled);
      }
      return _results;
    };
    conn = null;
    $rootScope.$on('sockjs:open', function() {
      $scope.connected = true;
      $scope.messages.push("<span class='text-success'>" + (dtNow()) + " Connection to matchmaking server established.</span>");
      $scope.messages.push("<span class='text-info'>" + (dtNow()) + " Waiting for a partner...</span>");
      $scope.closeConnection = function() {
        var e;
        try {
          conn.close();
          console.log("Closed existing RTCPeerConnection");
        } catch (_error) {
          e = _error;
          console.log("RTCPeerConnection already closed");
        }
        return $scope.waiting = true;
      };
      $scope.newConnection = function() {
        $scope.waiting = true;
        conn = new RTCPeerConnection(settings.peerConf);
        conn.addStream(stream);
        conn.onicecandidate = function(e) {
          return $scope.$apply(function() {
            console.log("onicecandidate triggered");
            if (e.candidate) {
              return sockjs.sendJSON({
                type: 'candidate',
                candidate: e.candidate
              });
            }
          });
        };
        conn.onaddstream = function(e) {
          return $scope.$apply(function() {
            console.log("Attaching remote stream");
            attachMediaStream($('#remote-video')[0], e.stream);
            $scope.waiting = false;
            return $scope.messages.push("<span class='text-success'>" + (dtNow()) + " Connected to someone!</span>");
          });
        };
        $timeout(function() {
          return sockjs.sendJSON({
            type: 'initialize'
          });
        }, 500);
        return console.log("Created new RTCPeerConnection");
      };
      $scope.refresh = function() {
        if (!$scope.waiting) {
          sockjs.sendJSON({
            type: 'leave'
          });
        }
        $scope.closeConnection();
        return $scope.newConnection();
      };
      $scope.nextUser = function(local) {
        if (local) {
          $scope.messages.push("<span class='text-danger'>" + (dtNow()) + " You disconnected</span>");
        } else {
          $scope.messages.push("<span class='text-danger'>" + (dtNow()) + " Your partner disconnected</span>");
        }
        $scope.messages.push("<span class='text-info'>" + (dtNow()) + " Waiting for a partner...</span>");
        return $scope.refresh();
      };
      $scope.sendChatMessage = function() {
        if ($scope.chatMessage.length > 0) {
          sockjs.sendJSON({
            type: 'chat',
            message: $scope.chatMessage
          });
        }
        return $scope.chatMessage = '';
      };
      $scope.newConnection();
      $rootScope.$on('sockjs:refresh', function() {
        return $scope.refresh();
      });
      $rootScope.$on('sockjs:createOffer', function() {
        return conn.createOffer(function(desc) {
          return conn.setLocalDescription(desc, function() {
            console.log("sent SDP offer");
            return sockjs.sendJSON({
              type: 'sdp',
              sdp: desc
            });
          });
        }, function(err) {
          return console.log(err);
        });
      });
      $rootScope.$on('sockjs:candidate', function(e, data) {
        conn.addIceCandidate(new RTCIceCandidate(data.candidate));
        return console.log("added remote ICE candidate");
      });
      $rootScope.$on('sockjs:sdp', function(e, data) {
        console.log("received remote SDP");
        return conn.setRemoteDescription(new RTCSessionDescription(data.sdp), function() {
          if (conn.remoteDescription.type === 'offer') {
            return conn.createAnswer(function(desc) {
              return conn.setLocalDescription(desc, function() {
                console.log("sent SDP answer");
                return sockjs.sendJSON({
                  type: 'sdp',
                  sdp: desc
                });
              });
            }, function(err) {
              return console.log(err);
            });
          }
        }, function(err) {
          return console.log(err);
        });
      });
      $rootScope.$on('sockjs:chat', function(e, data) {
        var from;
        from = null;
        if (data.self) {
          from = 'You';
        } else {
          from = 'Them';
        }
        return $scope.messages.push("" + (dtNow()) + " <b>" + from + ":</b> " + data.message);
      });
      $rootScope.$on('sockjs:localVerified', function(e, data) {
        return $scope.localVerified = data.verified;
      });
      $rootScope.$on('sockjs:remoteVerified', function(e, data) {
        return $scope.remoteVerified = data.verified;
      });
      $rootScope.$on('sockjs:leave', function() {
        console.log("Remote left");
        $scope.waiting = true;
        return $scope.nextUser(false);
      });
      return $rootScope.$on('sockjs:close', function() {
        return $scope.closed = true;
      });
    });
    return sockjs.newSocket(settings.sockUrl);
  }, function(e) {
    console.log("Webcam access denied - bailing");
    return $scope.$apply(function() {
      return $scope.gumDenied = true;
    });
  });
};
